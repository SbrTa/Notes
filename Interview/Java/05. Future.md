#### Parallel and Concurrent Processing in Java
Parallel processing is the simultaneous execution of multiple tasks, while concurrent processing is the simultaneous execution of multiple tasks that may interact with each other. Java provides several classes and interfaces in the java.util.concurrent package to support parallel and concurrent processing.

#### Executor vs ForkJoinPool

ExecutorService is a general-purpose executor that can be used to execute any type of task. It provides a flexible and easy-to-use API for executing tasks asynchronously. ForkJoinPool is a specialized executor that is designed specifically for executing tasks that can be split into smaller subtasks.

ForkJoinPool uses a work-stealing pattern, which means one thread can also execute a pending task from another thread. This improves efficiency in the case of ForkJoinTask as most of the ForkJoinTask algorithm spawn new tasks. 

#### Future
- Future is an interface 
- Belongs to java.util.concurrent package.
- Java 1.5
- It is used to represent the result of an asynchronous computation.
- used for storing a result received from a different thread
- The interface provides the methods to check if the computation is completed or not, to wait for its completion, and to retrieve the result of the computation.
- Methods - cancel(), isCancelled(), isDone(), get()
- The cancel() method is used to stop the task if it has not started. If the task has started and the mayInterrupt boolean value is true, it will interrupt that task too.
- The get() method returns the result of the task. It returns the result immediately if the task is completed; else, it will wait for its completion and then returns the result.
- 
```
    ExecutorService es = Executors.newSingleThreadExecutor();  

    //getting future  
    //the method submit() submits a value-returning task for execution and returns the Future  
    Future<String> future = es.submit(() ->   {  
        //sleep thread for 2 seconds      
        Thread.sleep(2000);  
        return "Welcome to Javatpoint";  
    });  

    //checks if the task is completed or not  
    while(!future.isDone()) {  
        System.out.println("The task is still in process.....");  
        Thread.sleep(200);  
    }  

    System.out.println("Task completed! getting the result");  
    //getting the result after completing the task  
    String result = future.get();  
    //prints the result   
    System.out.println(result);  
    es.shutdown();  
```

#### Completatble Future
- CompletableFuture is a class
- java.util.concurrent
- implements the **Future** and **CompletionStage** Interface
- since java 1.8
- It represents a future result of an **asynchronous computation**.
- used for storing a result received from a different thread
- It can be thought of as a container that holds the result of an asynchronous operation that is being executed in a different thread. It provides a number of methods to perform various operations on the result of the async computation.


#### Completable Future Methods

```

    /**
     * Returns a new CompletableFuture that is asynchronously completed
     * by a task running in the {@link ForkJoinPool#commonPool()} with
     * the value obtained by calling the given Supplier.
     *
     * @param supplier a function returning the value to be used
     * to complete the returned CompletableFuture
     * @param <U> the function's return type
     * @return the new CompletableFuture
     */
    public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier) {
        return asyncSupplyStage(asyncPool, supplier);
    }

    /**
     * Returns a new CompletableFuture that is asynchronously completed
     * by a task running in the given executor with the value obtained
     * by calling the given Supplier.
     *
     * @param supplier a function returning the value to be used
     * to complete the returned CompletableFuture
     * @param executor the executor to use for asynchronous execution
     * @param <U> the function's return type
     * @return the new CompletableFuture
     */
    public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier,
                                                       Executor executor) {
        return asyncSupplyStage(screenExecutor(executor), supplier);
    }

    /**
     * Returns a new CompletableFuture that is asynchronously completed
     * by a task running in the {@link ForkJoinPool#commonPool()} after
     * it runs the given action.
     *
     * @param runnable the action to run before completing the
     * returned CompletableFuture
     * @return the new CompletableFuture
     */
    public static CompletableFuture<Void> runAsync(Runnable runnable) {
        return asyncRunStage(asyncPool, runnable);
    }

    /**
     * Returns a new CompletableFuture that is asynchronously completed
     * by a task running in the given executor after it runs the given
     * action.
     *
     * @param runnable the action to run before completing the
     * returned CompletableFuture
     * @param executor the executor to use for asynchronous execution
     * @return the new CompletableFuture
     */
    public static CompletableFuture<Void> runAsync(Runnable runnable,
                                                   Executor executor) {
        return asyncRunStage(screenExecutor(executor), runnable);
    }
```

#### Handle errors — CompletableFuture

CompletableFuture provides a number of methods for handling errors that can occur during asynchronous operations. 
```
        CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {
            int result = 10 / 0; // Causes an ArithmeticException
            return result;
        });
        
        future.exceptionally(ex -> {
            System.out.println("Exception occurred: " + ex.getMessage());
            return 0; // Default value to return if there's an exception
        }).thenAccept(result -> {
            System.out.println("Result: " + result);
        });
```

In this example, we’re creating a CompletableFuture that will throw an ArithmeticException because we're dividing by zero. We're then calling the exceptionally() method to specify what to do if there's an exception. In this case, we're printing an error message to the console and returning a default value of 0.

We’re then calling the thenAccept() method to specify what to do when the operation is complete, whether there was an exception or not. In this case, we're simply printing the result to the console.

When we run this code, it will print “Exception occurred: / by zero” to the console followed by “Result: 0”.

#### Future vs CompletableFuture

**Blocking vs non-blocking:** Future is a blocking API, whereas CompletableFuture is non-blocking. With a Future object, you must call the get() method to retrieve the result, but this method blocks until the result is available. In contrast, with a CompletableFuture object, you can use various non-blocking methods to retrieve the result, such as thenApply(), thenAccept(), or join().

**Composition:** CompletableFuture provides a more powerful composition API than Future. With Future, it is difficult to chain multiple asynchronous operations together or to combine the results of multiple operations. CompletableFuture, on the other hand, provides methods such as thenCompose(), thenCombine(), and allOf() that make it easy to compose multiple asynchronous operations and to handle their results in a non-blocking way.

**Exception Handling:** CompletableFuture provides better exception handling than Future. With Future, you can only check if the computation completed successfully or not. If an exception occurs during the computation, you have to catch it explicitly. In contrast, with CompletableFuture, you can handle exceptions in a more declarative way using methods like exceptionally() and handle().\

**Completion:** With a Future object, there is no way to explicitly complete the future. Once you submit a task to an executor service and get a Future object in return, you can only wait for the task to complete. With CompletableFuture, you have more control over the completion of the future. You can complete it explicitly by calling complete(), completeExceptionally(), or cancel() methods.


#### Runnable vs Callable

There is a drawback of creating a thread with the Runnable interface, i.e., we cannot make a thread return result when it terminates, i.e., when the run() completes. In order to overcome this drawback, Java provides the Callable interface.

These are the two main differences between the Callable and Runnable methods:
  - The run() method is used for implementing the Runnable, whereas the call() method is used for implementing the Callable. The run() method doesn't return anything, whereas the call() method returns a result of completion.
  - The call() method can throw an exception, whereas the run() method cannot.

