# Functional Programming



#### ✅ What is a lambda expression, and what is its ideal use case?
A lambda expression is a function that can be referenced and passed around as an object. Lambda expressions helped introduce the functional programming paradigm to Java. Most Java functions exist inside an object’s scope, but lambda expressions do not and can be called from anywhere in the program.

Lambda expressions are often used to express instances of single-method classes more clearly and compactly than if you used the syntax of anonymous classes.



#### ✅ Explain the syntax of a lambda expression.
A lambda expression consists of:
  - **Arguments**: Formal parameters enclosed in parentheses. A lambda expression can have zero or more parameters.
  - **The array token ->**: Points arguments to the body of the lambda expression.
  - **Body**: Contains expressions or statements. If there is only one statement, curly braces are not required.

```(Arguments list)->{statements;}```


#### ✅ Functional interface?
A functional interface in Java 8 is an interface that can **only have one abstract method**. Functional interfaces are also referred to as SAM interfaces, or, Single Abstract Method interfaces. However, they can contain any number of default or static methods.
 
The **@FunctionalInterface annotation is optional** and can be used to prevent functional interfaces from having more than one abstract method.

Java 8 introduced four types of functional interfaces:
  - **Consumer**: Accepts an argument, returns nothing.
  - **Function**: Accepts an argument, returns a value.
  - **Predicate**: Accepts an argument, returns a boolean value.
  - **Supplier**: Does not accept an argument, returns a value.

#### ✅ What is a default method? What is a static method?
**Default**: The default method was introduced in Java 8 to allow for default implementations of methods within interfaces. This meant that existing interfaces could be backward compatible with their older versions. Lambda expressions could be used without having to provide the implementation code in the implementation class. Default methods can be overridden by classes that implement these interfaces.

**Static**: The static method introduced in Java 8 functions similarly to the default methods but cannot be overridden when implementing class. They are associated with the class in which they exist and can be called without creating an instance of that class.

#### ✅ What conditions must be fulfilled to match a lambda expression against a functional interface?
There are three conditions that must be satisfied:
  - The functional interface must only have one unimplemented method.
  - The parameters within the method must match the parameters of the lambda expression.
  - The return type of the method must match the return type of the lambda expression.


#### ✅ What is the Stream API, and how is it used?
The Stream API is used to convey collections of objects or primitives from a data source through a “stream” that performs computational operations on the various data elements passing through.

Three main components of a Stream:
  - A data source.
  - A set of intermediate operations to process the data.
  - A sole terminal operation to return the result.

#### ✅ What are intermediate operations, and what do they do?
Stream intermediate operations return another Stream as a result, allowing you to call multiple operations as a query. Intermediate operations are considered “lazy” because they do not evaluate until a terminal operation initiates.
  - map(): Returns the results of a Stream after a given function is applied to the elements of a Stream.
  - filter(): Returns a Stream consisting of elements that match a given predicate (another type of functional interface).
  - sorted(): Returns the elements of a Stream after they have been sorted.
  - distinct(): Returns a stream consisting of the distinct elements (Removes duplicate).
  - flatMap(): Is the combination of a map and a flat operation. This means you first apply the map function and then flatten the result. 
  - limit(): Returns a stream with the limited size given.
  - peek(): Returns a stream consisting of the elements of this stream, additionally performing the provided action on each element.
  - skip(): This method skips the given n elements and returns a Stream. This is the most useful when want to perform any operations on last n records or lines from a List or Stream.

#### ✅ What are terminal operations, and what do they do?
Terminal operations denote the end of a Stream and return the result.
  - collect(): Returns the collective result of all intermediate operations performed on the Stream.
  - forEach(): Accepts a consumer and iterates through each element of a Stream.
  - reduce(): Reduces the elements of a Stream and returns the result as a single value.
  - count(): Returns the number of elements in a Stream.
  - min(): Returns the smallest element from a Stream.
  - max(): Returns the greatest element from a Stream.


#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
#### ✅ 
